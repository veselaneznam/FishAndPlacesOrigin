<meta name="viewport" content="initial-scale=1.0, width=device-width"/>
<link rel="stylesheet" type="text/css" href="https://js.cit.api.here.com/v3/3.0/mapsjs-ui.css"/>
<script type="text/javascript" src="https://js.cit.api.here.com/v3/3.0/mapsjs-core.js"></script>
<script type="text/javascript" src="https://js.cit.api.here.com/v3/3.0/mapsjs-service.js"></script>
<script type="text/javascript" src="https://js.cit.api.here.com/v3/3.0/mapsjs-ui.js"></script>
<script type="text/javascript" src="https://js.cit.api.here.com/v3/3.0/mapsjs-mapevents.js"></script>
<div id="map" style="position:absolute; width:49%; height:100%; background:grey" ></div>
<div id="panel" style="position:absolute; width:49%; left:51%; height:100%; background:inherit" ></div>

<script type="text/javascript" charset="UTF-8">

    navigator.geolocation.getCurrentPosition(initMap);
    function initMap(position) {

        /**
         * Boilerplate map initialization code starts below:
         */
        var platform = new H.service.Platform({
            app_id: '{{ apiId }}',
            app_code: '{{ apiCode }}',
            useCIT: true,
            useHTTPS: true,
            language: 'bg'
        });
        var defaultLayers = platform.createDefaultLayers();

        // initialize a map - this map is centered over Europe
        var map = new H.Map(document.getElementById('map'),
            defaultLayers.normal.map, {
                center: {lat: Number('{{ dam.lat }}'), lng: Number('{{ dam.long }}')},
                zoom: 8
            });

        // MapEvents enables the event system
        // Behavior implements default interactions for pan/zoom (also on mobile touch environments)
        var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));

        // create default UI with layers provided by the platform
        var ui = H.ui.UI.createDefault(map, defaultLayers);


        var locationMarker = 'geo!' + position.coords.latitude + ',' + position.coords.longitude;


        var routingParameters = {
            // The routing mode:
            'mode': 'fastest;car;traffic:disabled',
            // The start point of the route:
            'waypoint0': locationMarker,
            // The end point of the route:
            'waypoint1': 'geo!' + '{{ dam.lat }}' + ',' + '{{ dam.long }}',
            // To retrieve the shape of the route we choose the route
            // representation mode 'display'
            'representation': 'display',
            'language': 'bg'
        };


        // Define a callback function to process the routing response:
        var onResult = function (result) {
            var route,
                routeShape,
                startPoint,
                endPoint,
                strip;
            if (result.response.route) {
                // Pick the first route from the response:
                route = result.response.route[0];
                // Pick the route's shape:
                routeShape = route.shape;

                // Create a strip to use as a point source for the route line
                strip = new H.geo.Strip();

                // Push all the points in the shape into the strip:
                routeShape.forEach(function (point) {
                    var parts = point.split(',');
                    strip.pushLatLngAlt(parts[0], parts[1]);
                });

                startPoint = route.waypoint[0].mappedPosition;
                endPoint = route.waypoint[1].mappedPosition;

                var panel = document.getElementById('panel');
                var routeLegend = route.leg[0];

                var html = '<div>';

                routeLegend.maneuver.forEach(function (instruction) {
                    html += instruction.instruction;
                });
                html += '</div>';
                panel.innerHTML = html;


                // Create a polyline to display the route:
                var routeLine = new H.map.Polyline(strip, {
                    style: {strokeColor: 'blue', lineWidth: 10},
                    arrows: {fillColor: 'white', frequency: 2, width: 0.8, length: 0.7}
                });

                // Create a marker for the start point:
                var startMarker = new H.map.Marker({
                    lat: startPoint.latitude,
                    lng: startPoint.longitude
                });

                // Create a marker for the end point:
                var endMarker = new H.map.Marker({
                    lat: endPoint.latitude,
                    lng: endPoint.longitude
                });

                // Add the route polyline and the two markers to the map:
                map.addObjects([routeLine, startMarker, endMarker]);


                // Set the map's viewport to make the whole route visible:
                map.setViewBounds(routeLine.getBounds());
                console.log(route.legend);
            }
        };


                // Get an instance of the routing service:
        var router = platform.getRoutingService();

        // Call calculateRoute() with the routing parameters,
        // the callback and an error callback function (called if a
        // communication error occurs):
        router.calculateRoute(routingParameters, onResult,
            function (error) {
                alert(error.message);
            });

    }

</script>

